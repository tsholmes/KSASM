
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text.Json;
using Brutal.Numerics;

namespace KSASM.Gauge
{
  public static class FontAtlas
  {
    private const int MIN_ASCII = 33;
    private const int MAX_ASCII = 126;
    private const int MIN_EXT = 128;
    private const int MAX_EXT = 254;
    private const int GLYPH_COUNT = 256;

    private const string GLSL_HEADER = """
      // AUTOGENERATED
      #include "GlyphAtlas.glsl"

      const GlyphAtlas TERM_ATLAS = GlyphAtlas(
      """;

    private const string GLSL_MIDDLE = """
        GlyphDef[](
      """;

    private const string GLSL_FOOTER = """
        )
      );
      """;

    public static void Generate(string csetPath, string jsonPath, string glslPath)
    {
      var codes = ParseCharSet(csetPath);
      var font = JsonSerializer.Deserialize<FontData>(File.ReadAllText(jsonPath), new JsonSerializerOptions
      {
        PropertyNameCaseInsensitive = true
      });

      var glyphs = new Dictionary<int, FontData.GlyphData>();
      foreach (var glyph in font.Glyphs)
        glyphs.Add(glyph.Unicode, glyph);

      if (File.Exists(glslPath))
        File.Delete(glslPath);
      using var f = File.OpenWrite(glslPath);
      using var w = new StreamWriter(f);

      w.WriteLine(GLSL_HEADER);
      w.WriteLine($"  {font.Atlas.DistanceRange},");
      w.WriteLine($"  vec2({font.Atlas.Width}, {font.Atlas.Height}),");
      w.WriteLine($"  {font.Metrics.Ascender},");
      w.WriteLine($"  {font.Metrics.Descender},");
      w.WriteLine($"  {font.Metrics.UnderlineY},");
      w.WriteLine($"  {font.Metrics.UnderlineThickness},");

      w.WriteLine(GLSL_MIDDLE);

      for (var i = 0; i < GLYPH_COUNT; i++)
      {
        var comma = i == GLYPH_COUNT - 1 ? "" : ",";
        if (codes[i] == -1)
        {
          w.WriteLine($"    GlyphDef(false, 1, vec4(0), vec4(0)){comma}");
          continue;
        }

        var glyph = glyphs[codes[i]];

        w.WriteLine($"    GlyphDef(");
        w.WriteLine($"      true, {glyph.Advance},");
        w.WriteLine($"      vec4({string.Join(',', glyph.PlaneBounds.Values)}),");
        w.WriteLine($"      vec4({string.Join(',', glyph.AtlasBounds.Values)})");
        w.WriteLine($"    ){comma}");
      }

      w.WriteLine(GLSL_FOOTER);
    }

    private static int[] ParseCharSet(string csetPath)
    {
      var codes = new int[GLYPH_COUNT];
      Array.Fill(codes, -1);

      for (var i = MIN_ASCII; i <= MAX_ASCII; i++)
        codes[i] = i;

      var lines = File.ReadAllLines(csetPath);
      var index = MIN_EXT;
      foreach (var line in lines[1..])
      {
        var ps = line.Split(" ");
        foreach (var p in ps)
          codes[index++] = int.Parse(p[2..], NumberStyles.AllowHexSpecifier);
      }
      if (index != MAX_EXT + 1)
        throw new InvalidOperationException($"{index} != {MAX_EXT + 1}");

      return codes;
    }

    private static double4 MapBounds(FontData.GlyphData.Bounds glyphBounds, double4 outerBounds)
    {
      var b = new double4(glyphBounds.Left, glyphBounds.Top, glyphBounds.Right, glyphBounds.Bottom);
      var osz = outerBounds.ZW - outerBounds.XY;

      var tl = (b.XY - outerBounds.XY) / osz;
      var br = (b.ZW - outerBounds.XY) / osz;
      return new(tl, br);
    }

    private class FontData
    {
      public AtlasData Atlas { get; set; }
      public MetricData Metrics { get; set; }
      public List<GlyphData> Glyphs { get; set; }

      public class AtlasData
      {
        public double DistanceRange { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
      }
      public class MetricData
      {
        public double Ascender { get; set; }
        public double Descender { get; set; }
        public double UnderlineY { get; set; }
        public double UnderlineThickness { get; set; }
      }
      public class GlyphData
      {
        public int Unicode { get; set; }
        public float Advance { get; set; }
        public Bounds PlaneBounds { get; set; }
        public Bounds AtlasBounds { get; set; }

        public class Bounds
        {
          public double Left { get; set; }
          public double Bottom { get; set; }
          public double Right { get; set; }
          public double Top { get; set; }

          public object[] Values => [Left, Top, Right, Bottom];
        }
      }
    }
  }
}