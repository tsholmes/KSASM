.import libtypes
.import libmath
.import libstring
.import libterm
.import libvehicle
.import libsystem

.region maindata 65536

.macro pi 3.14159265358979
.macro rad2deg { (180/.pi) }
.macro deg2rad { (.pi/180) }

# temp vars
tempq: .types.doublequat(tempq.)
tempv: .types.double3(tempv.)

# frame conversion quaternions
:f64 qroll90: 0.70710678119 0 0 0.70710678119
cci2enu: .types.doublequat(cci2enu.)
enu2body: .types.doublequat(enu2body.)

# state values
:f64 planet_avel: 0
surf_vel: .types.double3(surf_vel.)
body_vel: .types.double3(body_vel.)

# control constants
.macro lat_speed_scale 20 # lateral speed to reach max tilt
.macro lat_tilt_z 3 # z value of tilt vector when |(x,y)| <= 1
.macro rot_speed_scale { (10*.deg2rad) } # rot error to reach max rot speed
.macro rot_speed_max { (5*.deg2rad) } # max rot speed at max err
.macro max_vspeed 50 # above this speed engines will shut off
.macro min_vspeed { (-40) } # below this speed engines will turn on
.macro rot_deadband { (0.2*.deg2rad) }
.macro avel_deadband { (0.02*.deg2rad) }

# control values
rot_err: .types.double3(rot_err.)
avel_tgt: .types.double3(avel_tgt.)
avel_err: .types.double3(avel_err.)
:f64 vsign: 0

@0
.vehicle.init
.system.init
main:
  ld:u64 vehicle.patch.orbit.parent
  st:u64 system.hash_param
  ld:f64 system.angular_velocity
  st:f64 planet_avel

  # compute frame transforms
  ld:f64*4 system.cci2cce
  ld:f64*4 vehicle.enu2cce
  call dq.invert # cce -> enu
  call dq.concat
  st:f64*4 cci2enu

  ld:f64*4 vehicle.enu2cce
  ld:f64*4 vehicle.body2cce
  call dq.invert
  call dq.concat
  # concatenating enu2cce and cce2body still left it rolled -90deg
  ld:f64*4 qroll90
  call dq.concat
  st:f64*4 enu2body

  ld:u64 vehicle.hash
  st:u64 system.hash_param

  # compute enu surface velocity
  ld:f64*4 cci2enu
  ld:f64 planet_avel
  push 0:f64*2 # (0,0,avel)
  ld:f64*3 system.cci.pos
  call d3.cross
  mul:f64*3 (-1)
  ld:f64*3 system.cci.vel
  add:f64*3
  call d3dq.transform
  st:f64*3 surf_vel

  # calc velocity dir relative to body
  ld:f64*4 enu2body
  ld:f64*3 surf_vel
  call d3dq.transform
  st:f64*3 body_vel
  
  # calc wether we are pointing up or down
  ld:f64*4 enu2body
  push:f64 (0,0,1)
  call d3dq.transform
  sign:f64
  st:f64 vsign
  pop:f64*2

  # calc rotation error relative to body
  ld:f64*4 enu2body
  ld:f64*3 surf_vel
  mul:f64*3 (-1,-1,0)
  dup:f64*3 2
  .d3.mag
  dup:f64 2
  div:f64 .lat_speed_scale
  min:f64 1
  swz:f64 (1,0)
  div:f64
  dup:f64 3
  mul:f64*3
  sts:f64 (+16) .lat_tilt_z
  .d3.norm
  call d3dq.transform
  mul:f64*3 (-1)
  asin:f64*3
  sts:f64 (+0) 0
  push:f64 .rot_deadband
  call deadband3
  st:f64*3 rot_err

  ld:f64 vsign
  bpos:f64 skip_rot_err_adjust
  ld:f64*3 rot_err
  dup:f64*3 2
  sign:f64*3
  mul:f64*3 (.pi/2)
  add:f64*3
  st:f64*3 rot_err
  skip_rot_err_adjust:

  # calc target angular velocity
  ld:f64*3 rot_err
  mul:f64*3 (-1)
  dup:f64*3 2
  .d3.mag
  dup:f64 2
  div:f64 .rot_speed_scale
  min:f64 1
  mul:f64 .rot_speed_max
  swz:f64 (1,0)
  div:f64
  dup:f64 3
  mul:f64*3
  push:f64 .avel_deadband
  call deadband3
  st:f64*3 avel_tgt

  # calculate avel error
  ld:f64*3 avel_tgt
  ld:f64*3 vehicle.avel
  sub:f64*3
  push:f64 .avel_deadband
  call deadband3
  st:f64*3 avel_err

  st:u64 vehicle.inputs.thrust_command 0

  push:u64 (.vehicle.thrust.roll_left, .vehicle.thrust.roll_right)
  ld:f64 (avel_err+0)
  call do_axis
  push:u64 (.vehicle.thrust.pitch_down, .vehicle.thrust.pitch_up)
  ld:f64 (avel_err+8)
  call do_axis
  push:u64 (.vehicle.thrust.yaw_left, .vehicle.thrust.yaw_right)
  ld:f64 (avel_err+16)
  call do_axis

  ld:f64 vsign
  bneg:f64 engine_off # always turn off when pointing down

  ld:f64 (surf_vel+16)
  bgt:f64 skip_engine_on .min_vspeed
  st:u8 vehicle.inputs.engine_on 1
  skip_engine_on:

  ld:f64 (surf_vel+16)
  blt:f64 skip_engine_off .max_vspeed
  engine_off:
  st:u8 vehicle.inputs.engine_on 0
  skip_engine_off:

main_end:
  call term.clear

  ld:f64*3 surf_vel
  push:s48 "VEL SURF M/S"
  call printd3

  ld:f64*3 body_vel
  push:s48 "VEL BODY M/S"
  call printd3

  ld:f64*3 rot_err
  mul:f64*3 .rad2deg
  push:s48 "ROT ERR DEG"
  call printd3

  ld:f64*3 vehicle.avel
  mul:f64*3 .rad2deg
  push:s48 "AVEL DEG/S"
  call printd3

  ld:f64*3 avel_tgt
  mul:f64*3 .rad2deg
  push:s48 "AVEL TGT DEG/S"
  call printd3

  ld:f64*3 avel_err
  mul:f64*3 .rad2deg
  push:s48 "AVEL ERR DEG/S"
  call printd3

  sleep 1:u64
  jump main


:u8 fbuf: 0*64

# label:s48 d3:f64*3 -> _
# label @ f+0
# d3    @ f+6
#   .x  @ f+6
#   .y  @ f+14
#   .z  @ f+22
printd3:
  ldf:s48 (+0)
  call term.print
  call term.nl
  push 0:u64*8
  st:u64*8 fbuf
  push fbuf:p24
  ldf:f64 (+6)
  call str.ftoa_n3
  push (fbuf+11):p24
  ldf:f64 (+14)
  call str.ftoa_n3
  push (fbuf+22):p24
  ldf:f64 (+22)
  call str.ftoa_n3
  push:p24 (fbuf, 32)
  call term.print
  pop:s48*3 # ret vals from str.ftoa_n3
  adjf (+30)
  ret

# minv:f64 val:f64*3 -> rval:f64*3
# minv  @ f+0
# val.x @ f+8
# val.y @ f+16
# val.z @ f+24
# rval  @ f+8
deadband3:
  ldf:f64*3 (+8)
  abs:f64*3
  ldf:f64 (+0)
  dup:f64 3
  sub:f64*3
  sign:f64*3
  max:f64*3 0
  ldf:f64*3 (+8)
  mul:f64*3
  stf:f64*3 (+8)
  adjf (+8)
  ret

# x:f64 pflag:u64 nflag:u64 ->
# x     @ f+0
# pflag @ f+8
# nflag @ f+16
do_axis:
  ld:u64 vehicle.inputs.thrust_command
  ldf:f64 (+0)
  bzero:f64 do_axis_end
  ldf:f64 (+0)
  bpos:f64 do_axis_pos
  ldf:u64 (+8) # pflag
  or:u64
  jump do_axis_end
do_axis_pos:
  ldf:u64 (+16) # nflag
  or:u64
do_axis_end:
  st:u64 vehicle.inputs.thrust_command
  adjf (+24)
  ret
