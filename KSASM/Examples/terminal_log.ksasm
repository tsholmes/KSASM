.import libsystem
.import libvehicle
.import libstring
.import libterm

.region maindata 1024

:u64 last_inputs: 0
:u64 temp: 0

:s48 s_roll_right: "Roll Right"
:s48 s_roll_left: "Roll Left"
:s48 s_pitch_up: "Pitch Up"
:s48 s_pitch_down: "Pitch Down"
:s48 s_yaw_right: "Yaw Right"
:s48 s_yaw_left: "Yaw Left"

:s48 s_intro: "Logging Rotation Inputs..."

.macro loginput(flag, string) {
  push:u64 flag
  ld:s48 string
  call loginput
}

@0
premain:
  .system.init
  .vehicle.init
  .term.init
  call term.clear
  ld:s48 s_intro
  call term.print
main:
  .loginput(.vehicle.thrust.roll_right, s_roll_right)
  .loginput(.vehicle.thrust.roll_left, s_roll_left)
  .loginput(.vehicle.thrust.pitch_up, s_pitch_up)
  .loginput(.vehicle.thrust.pitch_down, s_pitch_down)
  .loginput(.vehicle.thrust.yaw_right, s_yaw_right)
  .loginput(.vehicle.thrust.yaw_left, s_yaw_left)
  ld:u64 vehicle.inputs.thrust_command
  st:u64 last_inputs
  sleep (1):u64
  jump main

# flag:u64 string:s48 ->
# flag   @ f+6
# string @ f+0
loginput:
  # new_inputs = ~last_inputs & inputs
    ld:u64 last_inputs
    not:u64
    ld:u64 vehicle.inputs.thrust_command
    and:u64
  # pressed = new_inputs & flag
    ldf:u64 (+6)
    and:u64
  bzero:u64 loginput.skip
  # if pressed, print string to terminal
    call term.nl
    ldf:s48 (+0)
    call term.print
loginput.skip:
  adjf (+14)
  ret