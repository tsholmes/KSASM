.import libtypes

# general math utilites for vectors/quaternions
.ifndef libmath { .macro libmath

.region libmath 2048

:f64 v.tempv0: 0*8 v.tempv1: 0*8 v.tempv2: 0*8 v.tempv3: 0*8

.macro v.dot(a, b, wid) {
  mul:f64 wid a, b
  sum:f64 wid a, $(0)
}

# a[0] = a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
.macro d3.dot(a, b) .v.dot(a, b, *3)

# v[0] = |v|
.macro d3.mag(v) {
  .d3.dot(v, v)
  sqrt:f64 v, _
}

# |v| = 1
.macro d3.norm(v) {
  copy:f64*3 v.tempv0, v
  .d3.mag(v.tempv0)
  max:f64 v.tempv0, $(1e-8)
  swz:f64*3 v.tempv0, $(0,0,0)
  div:f64*3 v, v.tempv0
}

# a = (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
.macro d3.cross(a, b) {
  copy:f64*3 v.tempv0, a
  copy:f64*3 v.tempv1, b
  swz:f64*6 v.tempv0, $(1,2,2,0,0,1)
  swz:f64*6 v.tempv1, $(2,1,0,2,1,0)
  mul:f64*6 v.tempv0, v.tempv1
  mul:f64*6 v.tempv0, $(1,-1,1,-1,1,-1)
  sum:f64*6 v.tempv0, $(0,0,1,1,2,2)
  copy:f64*3 a, v.tempv0
}

# a[0] = a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]
.macro dq.dot(a, b) .v.dot(a, b, *4)

# a = (
#  +a[0]*b[3] -a[1]*b[2] +a[2]*b[1] +a[3]*b[0] # (+3, -2, +1, +0)
#  +a[0]*b[2] +a[1]*b[3] -a[2]*b[0] +a[3]*b[1] # (+2, +3, -0, +1)
#  -a[0]*b[1] +a[1]*b[0] +a[2]*b[3] +a[3]*b[2] # (-1, +0, +3, +2)
#  -a[0]*b[0] -a[1]*b[1] -a[2]*b[2] +a[3]*b[3] # (-0, -1, -2, +3)
# )
# aka hamilton_wzyx
.macro dq.concat(a, b) {
  copy:f64*4 v.tempv0, a
  swz:f64*8 v.tempv0, $(0,1,2,3,0,1,2,3)
  copy:f64*4 v.tempv1, b
  swz:f64*8 v.tempv1, $(3,2,1,0,2,3,0,1)
  mul:f64*8 v.tempv1, $(1,-1,1,1,1,1,-1,1)
  mul:f64*8 v.tempv1, v.tempv0
  sum:f64*8 v.tempv1, $(0,0,0,0,1,1,1,1)
  copy:f64*4 v.tempv2, b
  swz:f64*8 v.tempv2, $(1,0,3,2,0,1,2,3)
  mul:f64*8 v.tempv2, $(-1,1,1,1,-1,-1,-1,1)
  mul:f64*8 v.tempv2, v.tempv0
  sum:f64*8 v.tempv2, $(2,2,2,2,3,3,3,3)
  copy:f64*4 a, v.tempv1
  add:f64*4 a, v.tempv2
}

# r = conj(r)/(r.r)
.macro dq.invert(r) {
  copy:f64*4 v.tempv0, r
  mul:f64*4 r, $(-1,-1,-1,1)
  .v.dot(v.tempv0, v.tempv0, *4)
  swz:f64*4 v.tempv0, $(0)
  div:f64*4 r, v.tempv0
}

# dq.concat(
#   dq.concat(
#     (-r[0], -r[1], -r[2], r[3]),
#     (v[0], v[1], v[2], 1),
#   ),
#   (r[0], r[1], r[2], r[3])
# )
.macro d3dq.transform(v, r) {
  copy:f64*3 v.tempv3, v
  copy:f64 $[v.tempv3+8*3], $(1)
  copy:f64*4 $[v.tempv3+8*4], $(-1,-1,-1,1)
  mul:f64*4 $[v.tempv3+8*4], r
  .dq.concat($[v.tempv3+8*4], v.tempv3)
  .dq.concat($[v.tempv3+8*4], r)
  copy:f64*3 v, $[v.tempv3+8*4]
}

}