.import libtypes

# general math utilites for vectors/quaternions
.ifndef libmath { .macro libmath

.region libmath 2048

.macro pi 3.14159265358979

.macro v.dot(wid) {
  mul:f64 wid
  addr:f64 wid
}

# a[0] = a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
.macro d3.dot .dot(*3)

# v[0] = |v|
.macro d3.mag {
  dup:f64*3 2
  .d3.dot
  sqrt:f64
}

# |v| = 1
.macro d3.norm(v) {
  dup:f64*3 2
  .d3.mag
  max:f64 1e-8
  dup:f64 3
  div:f64*3
}

# a: +0 :f64*3
# b: +24 :f64*3
# a b -> (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
d3.cross:
  ldf:f64*6 (+0)
  swz:f64 (1,2,0,5,3,4)
  mul:f64*3
  ldf:f64*6 (+0)
  swz:f64 (2,0,1,4,5,3)
  mul:f64*3
  sub:f64*3
  stf:f64*3 (+24)
  adjf (+24)
  ret

# a[0] = a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]
.macro dq.dot .v.dot(*4)

# b: +0 :f64*4
# a: +32 :f64*4
# c = (
#  +a[0]*b[3] +a[1]*b[2] -a[2]*b[1] +a[3]*b[0]
#  -a[0]*b[2] +a[1]*b[3] +a[2]*b[0] +a[3]*b[1]
#  +a[0]*b[1] -a[1]*b[0] +a[2]*b[3] +a[3]*b[2]
#  -a[0]*b[0] -a[1]*b[1] -a[2]*b[2] +a[3]*b[3]
# )
# a b -> c
dq.concat:
  ldf:f64*8 (+0)
  swz:f64 (4,4,4,4,3,2,1,0) # column 1
  mul:f64*4
  mul:f64*4 (+1,-1,+1,-1)
  ldf:f64*8 (+0)
  swz:f64 (5,5,5,5,2,3,0,1) # column 2
  mul:f64*4
  mul:f64*4 (+1,+1,-1,-1)
  add:f64*4
  ldf:f64*8 (+0)
  swz:f64 (6,6,6,6,1,0,3,2) # column 3
  mul:f64*4
  mul:f64*4 (-1,+1,+1,-1)
  add:f64*4
  ldf:f64*8 (+0)
  swz:f64 (7,7,7,7,0,1,2,3) # column 4
  mul:f64*4
  add:f64*4
  stf:f64*4 (+32)
  adjf (+32)
  ret

# b: +0 :f64*4
# a: +32 :f64*4
# c = (
#  +a[0]*b[3] -a[1]*b[2] +a[2]*b[1] +a[3]*b[0]
#  +a[0]*b[2] +a[1]*b[3] -a[2]*b[0] +a[3]*b[1]
#  -a[0]*b[1] +a[1]*b[0] +a[2]*b[3] +a[3]*b[2]
#  -a[0]*b[0] -a[1]*b[1] -a[2]*b[2] +a[3]*b[3]
# )
# a b -> c
dq.hamilton:
  ldf:f64*8 (+0)
  swz:f64 (4,4,4,4,3,2,1,0) # column 1
  mul:f64*4
  mul:f64*4 (+1,+1,-1,-1)
  ldf:f64*8 (+0)
  swz:f64 (5,5,5,5,2,3,0,1) # column 2
  mul:f64*4
  mul:f64*4 (-1,+1,+1,-1)
  add:f64*4
  ldf:f64*8 (+0)
  swz:f64 (6,6,6,6,1,0,3,2) # column 3
  mul:f64*4
  mul:f64*4 (+1,-1,+1,-1)
  add:f64*4
  ldf:f64*8 (+0)
  swz:f64 (7,7,7,7,0,1,2,3) # column 4
  mul:f64*4
  add:f64*4
  stf:f64*4 (+32)
  adjf (+32)
  ret

# a: +0 :f64*4
# a -> conj(a)/(a.a)
dq.invert:
  ldf:f64*4 (+0)
  dup:f64*4 3
  .dq.dot
  dup:f64 4
  div:f64*4
  mul:f64*4 (-1,-1,-1,1)
  stf:f64*4 (+0)
  ret

# angle: +0 :f64
# axis: +8 :f64*3
# angle axis -> quat:f64*4
dq.from_axis_angle:
  ldf:f64 (+0)
  mul:f64 0.5
  cos:f64 # cos(angle/2)
  ldf:f64*4 (+0)
  mul:f64 0.5
  sin:f64
  dup:f64 3
  mul:f64*3 # sin(angle/2) * axis
  stf:f64*4 (+0)
  ret

# angles: +0 :f64*3
#   roll: +0 :f64
#   pitch: +8 :f64
#   yaw: +16 :f64
# angles -> quat:f64*4
# +8 start frame
dq.from_yaw_pitch_roll:
  adjf (-8)
  ldf:f64*3 (+8)
  mul:f64*3 0.5
  cos:f64*3             # d e f @f-30
  ldf:f64*3 (+8)
  mul:f64*3 0.5
  sin:f64*3             # a b c @f-54

  ldf:f64*3 (-30)
  mulr:f64*3            # def
  ldf:f64*6 (-54)
  swz:f64 (1,2,0,3,4,5) # b c a d e f
  mul:f64*3             # bd ce af
  ldf:f64*3 (-30)
  swz:f64 (2,0,1)       # f d e
  mul:f64*3             # bdf ced afe def

  ldf:f64*3 (-54)
  mulr:f64*3            # abc
  ldf:f64*6 (-54)
  swz:f64 (2,0,1,4,5,3) # c a b e f d
  mul:f64*3             # ce af bd
  ldf:f64*3 (-54)
  mul:f64*3             # ace abf bcd
  mul:f64*4 (1,-1,-1,1) # ace -abf -bcd abc
  add:f64*4             # bdf+ace ced-abf afe-bcd def+abc

  stf:f64*4 (+0)
  pop:f64*6
  ret

# v: +0 :f64*3
# r: +24 :f64*4
# dq.hamilton(dq.hamilton(conj(r), (...v, 1)), r)
d3dq.transform:
  ldf:f64*4 (+24)
  mul:f64*4 (-1,-1,-1,1)
  push 1:f64
  ldf:f64*3 (+0)
  call dq.hamilton
  ldf:f64*4 (+24)
  call dq.hamilton
  stf:f64*3 (+32)
  pop:f64
  adjf (+32)
  ret

}